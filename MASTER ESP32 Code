// To do:

/* 
1: Fix Motor Pins When Installed Into Body
2: Write Be_Self();
3: Write Tell_Shout(); Communication System to Slave ESP32
4: Write alone();
5: Finish rock paper scissors + faces
6. Finish Remaining Behaviours (+ Win and Lose)

*/


// ==============================
// Global Variables
// ==============================



// ==============================
// Pre Setup
// ==============================
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <ESP32Servo.h>
#include <esp_now.h>
#include <WiFi.h>


//Servo
Servo ARM1;

//OLED
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET     -1
#define SCREEN_ADDRESS 0x3C
Adafruit_SSD1306 oled(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// ESP NOW COMMUNICATION
String PREVIOUS_COMMAND = "ERROR";
String COMMAND = "ERROR";
String LISTEN_COMMAND = "ERROR";
String RPS_COMMAND = "ERROR";
String MOVEMENT_COMMAND = "ERROR";
bool FIRST_BOOT = true;
bool MOVING = false;
bool RPSING = false;
bool LISTENING = false;

uint8_t peerMac[] = {0x94, 0x54, 0xC5, 0xB5, 0xC6, 0x8C}; // ESP32 #2 MAC


// ==============================
// Pins
// ==============================

// Servo
const int ARM1_PIN = 15;

// Wheels
// FRONT (WHITE): A IS RIGHT B IS LEFT

const int FRONT_LEFT_FORWARD_PIN = 33;
const int FRONT_RIGHT_FORWARD_PIN = 26;

const int FRONT_LEFT_REVERSE_PIN = 32;
const int FRONT_RIGHT_REVERSE_PIN = 25;

// REAR (GREY): A IS RIGHT B IS LEFT
const int REAR_LEFT_FORWARD_PIN = 4;
const int REAR_RIGHT_FORWARD_PIN = 13;

const int REAR_LEFT_REVERSE_PIN = 27;
const int REAR_RIGHT_REVERSE_PIN = 12;

// Master ESP Troubleshooting LED
const int LED_PIN = 2;



// ==============================
// Convinience Stuff
// ==============================


void STARTUP() {
  for(int count=0; count<15; count++) {
    pinMode(2, HIGH);
    delay(100);
    pinMode(2, LOW);
    delay(100);
  }
  Serial.println("READY");
}


// ==============================
// ESP NOW COMMUNICATION
// ==============================

void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
    Serial.println(status == ESP_NOW_SEND_SUCCESS ? "MASTER> SENT SLAVE: " + PREVIOUS_COMMAND: "MASTER> FAILED TO SEND");
}

void OnDataRecv(const esp_now_recv_info_t *recvInfo, const uint8_t *incomingData, int len) {
  String COMMAND = String((char*)incomingData);
  if(MOVING) {
    MOVEMENT_COMMAND = COMMAND;
    Serial.print("SLAVE> MOVING> "); Serial.println(COMMAND);
  }
  else if (RPSING) {
    RPS_COMMAND = COMMAND;
    Serial.print("SLAVE> RPSING> "); Serial.println(COMMAND);
  }
  else if (LISTENING) {
    LISTEN_COMMAND = COMMAND;
    Serial.print("SLAVE> LISTENING> "); Serial.println(COMMAND);
  }
  else {
    Serial.println ("ERROR: NOT MOVEMENT, RPSING OR LISTENING");
  }
}


void sendMessage(String msg) {
    PREVIOUS_COMMAND = msg;  // Store the message before sending
    esp_now_send(peerMac, (uint8_t *)msg.c_str(), msg.length() + 1);
}

ESP_NOW_Broadcast_Peer broadcast_peer(ESPNOW_WIFI_CHANNEL, WIFI_IF_STA, NULL);

// ==============================
// TELL SHOUTS
// ==============================

void Tell_Shout(String COMMAND) {
  if (COMMAND.equals("STARTUP")) {
    sendMessage("STARTUP");
  }
  else if(COMMAND.equals("LISTEN")) {
    sendMessage("LISTEN");
  }
  else if (COMMAND.equals("RPS")) {
    sendMessage("RPS");
  }
  else if (COMMAND.equals("MOVEMENT")) {
    sendMessage("MOVEMENT");
  }
  else {
    Serial.println("MASTER> TELL SHOUT ERROR UNRECOGNISED COMMAND: "+COMMAND);
  }
}

// ==============================
// Movement Functions 
// ==============================

void go_forward(double value) {
  const double duration = value*1000.0; // Value multiplier here needs to be calibrated when prototype is made
  static  double start = 0.0;
  static bool moving = false;

  if (!moving) {
    start = millis(); 
    moving = true;
  } 
  
  while(moving) {
    if (millis() - start < duration) {
    digitalWrite(FRONT_RIGHT_FORWARD_PIN, HIGH);
    digitalWrite(REAR_LEFT_FORWARD_PIN, HIGH);
    digitalWrite(FRONT_LEFT_FORWARD_PIN, HIGH);
    digitalWrite(REAR_RIGHT_FORWARD_PIN, HIGH);
  } else {
    digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
    digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
    digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
    digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
    moving = false;
    } 
  }
}

void go_back(double value) {
  const double duration = value*1000.0; // Value multiplier here needs to be calibrated when prototype is made
  static double start = 0.0;
  static bool moving = false;

  if (!moving) {
    start = millis(); 
    moving = true;
  } 
  
  while(moving) {
    if (millis() - start < duration) {
    digitalWrite(FRONT_RIGHT_REVERSE_PIN, HIGH);
    digitalWrite(REAR_LEFT_REVERSE_PIN, HIGH);
    digitalWrite(FRONT_LEFT_REVERSE_PIN, HIGH);
    digitalWrite(REAR_RIGHT_REVERSE_PIN, HIGH);
  } else {
    digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
    digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
    digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
    digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
    moving = false;
    } 
  }
}

void rotate_left (double value) { // Scuffed Method Since we're not using a gyro - in degrees
  const double duration = value*10.0; // Value multiplier here needs to be calibrated when prototype is made
  static double start = 0.0;
  static bool rotating = false;

  if (!rotating) {
    start = millis(); 
    rotating = true;
  } 

  while(rotating) {
    if (millis() - start < duration) {
    digitalWrite(FRONT_RIGHT_FORWARD_PIN, HIGH);
    digitalWrite(REAR_LEFT_FORWARD_PIN, HIGH);
    digitalWrite(FRONT_LEFT_REVERSE_PIN, HIGH);
    digitalWrite(REAR_RIGHT_REVERSE_PIN, HIGH);
  } else {
    digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
    digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
    digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
    digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
    rotating = false;
    } 
  }
}

void rotate_right (double value) { // Scuffed Method Since we're not using a gyro - in degrees
  const double duration = value*10.0; // Value multiplier here needs to be calibrated when prototype is made
  static double start = 0.0;
  static bool rotating = false;

  if (!rotating) {
    start = millis(); 
    rotating = true;
  } 
  
  while(rotating) {
    if (millis() - start < duration) {
    digitalWrite(FRONT_LEFT_FORWARD_PIN, HIGH);
    digitalWrite(REAR_RIGHT_FORWARD_PIN, HIGH);
    digitalWrite(FRONT_RIGHT_REVERSE_PIN, HIGH);
    digitalWrite(REAR_LEFT_REVERSE_PIN, HIGH);
  } else {
    digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
    digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
    digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
    digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
    rotating = false;
    } 
  }
  
}

void shake(int intensity, int number_of_times) {
  for(int count=0;count<number_of_times;count++) {
    rotate_left(intensity);
    rotate_right(intensity);
  }
}

void arms(int degrees) {
  ARM1.write(degrees);
}

void arms_reset() {
  ARM1.write(0);
}

void arms_shake(int degrees, int number_of_times) {
  for(int count=0;count<number_of_times;count++) {
    arms_reset();
    delay(1000);
    ARM1.write(degrees);
  }
}

// ==============================
// Faces
// ==============================

void Blink_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(29, 28, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 28, 34, 15, 45, WHITE);
  oled.display();
  delay(100);
}
void Neutral_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(2500);
  Blink_FACE();
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(2500);
  Blink_FACE();
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
}

void Happy_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(29, 21, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 21, 34, 15, 45, WHITE);
  oled.fillRoundRect(32, 24, 29, 15, 45, BLACK);
  oled.fillRoundRect(68, 24, 29, 15, 45, BLACK);
  oled.display();
  delay(350);
  oled.clearDisplay();
  oled.fillRoundRect(29, 23, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 23, 34, 15, 45, WHITE);
  oled.fillRoundRect(31, 26, 29, 15, 45, BLACK);
  oled.fillRoundRect(67, 26, 29, 15, 45, BLACK);
  oled.display();
  delay(350);
}

void Idle_FACE() {
  oled.clearDisplay();
  oled.drawRect(43, 18, 18, 32, WHITE);
  oled.drawRect(78, 18, 18, 32, WHITE);
  oled.display();
}

void Angry_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(29, 18, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 18, 34, 15, 45, WHITE);
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1000);
}

void Look_Around_FACE() {
  //Left
  oled.clearDisplay();
  oled.fillRoundRect(28, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(64, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1500);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  //Blink
  oled.clearDisplay();
  oled.fillRoundRect(29, 28, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 28, 34, 15, 45, WHITE);
  oled.display();
  delay(100);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1750);
  //Blink
  oled.clearDisplay();
  oled.fillRoundRect(29, 28, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 28, 34, 15, 45, WHITE);
  oled.display();
  delay(100);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  //Right
  oled.clearDisplay();
  oled.fillRoundRect(48, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(84, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1500);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
}

void Rock_FACE() {

}

void Paper_FACE() {

}

void Scissors_FACE() {

}

void BOOTING() {
  oled.clearDisplay();
  oled.drawRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.drawRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
}

// ==============================
// Behaviours
// ==============================

void Be_Self() {
  Happy_FACE();
  Idle_FACE();
  rock_paper_scissors();
  Idle_FACE();
}

void Listen() {
  Tell_Shout("LISTEN");
    if (COMMAND == "Be_Self_alone") {
      alone();
    }
    else {
      if (COMMAND == "Be_Self") {
        Be_Self();
      }
      else {
        if (COMMAND == "Manual_ON") {
          Movement_Listen();
        }
        else {
          if (COMMAND == "RPS") {
            rock_paper_scissors();
          }
          else {
            Serial.println("Listen: Unrecognised Command: " + COMMAND);
          }
        }
      }
    }
  }
}

void Movement_Listen() {

  MOVING = true;
  Serial.println("MASTER> Entered Manual Mode");
  while(MOVING) {
    Tell_Shout("MOVEMENT");
    
      if(MOVEMENT_COMMAND == "Manual_OFF") {
        MOVING = false;
      }
      else {
        if (MOVEMENT_COMMAND == "FORWARD") {
        Serial.println("MASTER> Motion: Going Forward");
        go_forward(0.25);
        }
        else {
          if (MOVEMENT_COMMAND == "REVERSE") {
          Serial.println("MASTER> Motion: Going Back");
          go_back(0.25);
          }
          else {
            if (MOVEMENT_COMMAND == "LEFT") {
            Serial.println("MASTER> Motion: Turning Left");
            rotate_left(45);
            }
            else {
              if (MOVEMENT_COMMAND == "RIGHT") {
              Serial.println("MASTER> Motion: Turning Right");
              rotate_right(45);
              }
              else {
                Serial.println("MASTER> Movement_Listen: Unrecognised command: " + command);
                Error();
              }
            }
          }
        }
      }
  }
  digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
  digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
  digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
  digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
  digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
  digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
  digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
  digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
  Serial.println("MASTER> Exitted Manual Mode")
}

int RPS_Listen() {
  Serial.println("MASTER> RPS LISTENING")
  while(RPSING) {
    Tell_Shout("RPS");
    if (RPS_COMMAND == "ROCK") {
      RPSING = false;
      return 1;
    }
    else {
      if (RPS_COMMAND == "PAPER") {
        RPSING = false;
        return 2;
      }
      else {
        if (RPS_COMMAND == "SCISSORS") {
          RPSING = false;
          return 3;
        }
        else {
          Serial.println("RPS_Listen: Unrecognised Entry" + RPS_command);
        }
      }
    }
  }
}


void playful() {
  Happy_FACE();
  Listen();
}


void alone() {
  Idle_FACE();
  arms(15);
  delay(300);
  arms(0);
  delay(300);
  arms(25);
  delay(300);
  arms(0);
  delay(300);
  arms(15);
  delay(300);
  arms(0);
  delay(300);
  arms(25);
  delay(300);
  arms(0);
  delay(300);
  arms(15);
  delay(300);
  arms(0);
  delay(300);
  arms(25);
  delay(300);
  arms(0);
}

void Win() {
  Happy_FACE();
  arms(90);
  delay(300);
  arms(0);
  delay(300);
  arms(90);
  delay(300);
  arms(0);
  delay(300);
  arms(90);
  delay(300);
  arms(0);
}

void Lose() {
  Angry_FACE();
  arms(45);
  delay(300);
  arms(0);
  delay(300);
  arms(45);
  delay(300);
  arms(0);
  delay(300);
  arms(45);
  delay(300);
  arms(0);

}


// ==============================
// Play Functions
// ==============================

void rock_paper_scissors() {
  int BOT_PICK = random(1, 4);
  int PLAYER_PICK;
  RPSING = true;
  
  while(RPSING) {
    SHOW_RPS();
    delay(3000);
    arms(90);
    delay(350);
    arms(45);
    delay(350);
    arms(90);
    delay(350);
    arms(45);
    delay(350);
    arms(90);
    delay(350);
    arms(0);
    PLAYER_PICK = RPS_Listen();

    if(BOT_PICK == PLAYER_PICK) {
      Angry_FACE();
      delay(3000);
    }
    else {
      if(BOT_PICK == 1 && PLAYER_PICK == 3) { // BOT ROCK, PLAYER SCISSORS
        ROCK_FACE();
        delay(1000);
        Win();
      }
      else {
        if(BOT_PICK == 2 && PLAYER_PICK == 1) { // BOT PAPER, PLAYER ROCK
          PAPER_FACE();
          delay(1000);
          Win();
        }
        else {
          if(BOT_PICK == 3 && PLAYER_PICK == 2) { // BOT SCISSORS, PLAYER PAPER
            SCISSORS_FACE();
            delay(1000);
            Win();
          }
          else {
            if(BOT_PICK == 1) {
              ROCK_FACE();
              delay(1000);
              Lose();
            }
            else {
              if(BOT_PICK == 2) {
                PAPER_FACE();
                delay(1000);
                Lose();
              }
              else {
                if(BOT_PICK == 3) {
                  SCISSORS_FACE();
                  delay(1000);
                  Lose();
                }
              }
            }
          }
        }
      }
    }
  }
}





// ==============================
// Other
// ==============================

void Error() {
  digitalWrite(LED_PIN, HIGH);
  delay(1000);
  digitalWrite(LED_PIN, LOW);
}

// ==============================
// Setup & Loop
// ==============================

void setup() {
  // Serial
  Serial.begin(115200);

  // ESP NOW
  WiFi.mode(WIFI_STA);
    
  if (esp_now_init() != ESP_OK) {
      Serial.println("ESP-NOW Init Failed!");
      return;
  }
    
  esp_now_register_send_cb(OnDataSent);
  esp_now_peer_info_t peerInfo = {};
  memcpy(peerInfo.peer_addr, peerMac, 6);
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;
    
  if (esp_now_add_peer(&peerInfo) != ESP_OK) {
      Serial.println("Failed to add peer");
      return;
  }
    
  esp_now_register_recv_cb(OnDataRecv);
  
  
  // Servo
  ARM1.attach(ARM1_PIN);
  // Motor Outputs
  pinMode(FRONT_LEFT_FORWARD_PIN, OUTPUT);
  pinMode(FRONT_RIGHT_FORWARD_PIN, OUTPUT);
  pinMode(FRONT_LEFT_REVERSE_PIN, OUTPUT);
  pinMode(FRONT_RIGHT_REVERSE_PIN, OUTPUT);
  pinMode(REAR_LEFT_FORWARD_PIN, OUTPUT);
  pinMode(REAR_RIGHT_FORWARD_PIN, OUTPUT);
  pinMode(REAR_LEFT_REVERSE_PIN, OUTPUT);
  pinMode(REAR_RIGHT_REVERSE_PIN, OUTPUT);
  pinMode(LED_PIN, OUTPUT);

  digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
  digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
  digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
  digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
  digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
  digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
  digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
  digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
  digitalWrite(LED_PIN, LOW);

  // OLED 
  if (!oled.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("failed to start SSD1306 OLED"));
    Error();
    while (1);
  }
  delay(2000);
  oled.setCursor(0, 0);
  oled.clearDisplay();


  BOOTING();
}

void loop() {
  if(FIRST_BOOT) {
    while(FIRST_BOOT) {
      Tell_Shout("STARTUP");
      if (Serial.available()) {
        String Active = Serial.readStringUntil('\n');
        input.trim();
        if(Active=="READY") {
          FIRST_BOOT = false;
          STARTUP();
        }
      }
    }
  }
  else {
    Listen();
  }
}
