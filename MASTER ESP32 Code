/*
  Signed Naim Iftekhar Rahman (TDMJ10)
  tdmj10@gmail.com
  naimiftekharrahman@gmail.com
  Student of Bangldesh BRAC University 24201190
  ROBU FALL 2024 BOR PROJECT
  TEAM I-NPC


  May This Code Inspire Others In The Future

        CAUTION:
       ---------
        THIS CODE CAN CAUSE WINDOWS BLUE SCREENS OF DEATH (IQRL_NOT_LESS_OR_EQUAL)
        DUE TO EXCESSIVE SERIAL PRINTS. BE FORWARNED

        THIS CODE IS UNTESTED ON MAC OS IT MAY CAUSE KERNEL PANICS

 To do:
==========
1: Fix Motor Pins When Installed Into Body
2: Write Be_Self();
3: Write Tell_Shout(); Communication System to Slave ESP32
4: Write alone();
5: Finish rock paper scissors + faces
6. Finish Remaining Behaviours (+ Win and Lose)
7. Add Servo Movements to most functions

*/


// ==============================
// Global Variables
// ==============================



// ==============================
// Pre Setup
// ==============================
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <ESP32Servo.h>
#include <esp_now.h>
#include <WiFi.h>


//Servo
Servo ARM1;

//OLED
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET     -1
#define SCREEN_ADDRESS 0x3C
Adafruit_SSD1306 oled(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// ESP NOW COMMUNICATION
String PREVIOUS_COMMAND = "ERROR";
String COMMAND = "ERROR";
String LISTEN_COMMAND = "ERROR";
String RPS_COMMAND = "ERROR";
String MOVEMENT_COMMAND = "ERROR";
bool MOVING = false;
bool RPSING = false;
bool STARTUP_CHECK_COMPLETE = false;
bool LISTENING = false;

uint8_t peerMac[] = {0x94, 0x54, 0xC5, 0xB5, 0xC6, 0x8C}; // ESP32 #2 MAC


// ==============================
// Pins
// ==============================

// Servo
const int ARM1_PIN = 15;

// Wheels
// FRONT (WHITE): A IS RIGHT B IS LEFT
 
const int FRONT_LEFT_FORWARD_PIN = 33;
const int FRONT_RIGHT_FORWARD_PIN = 26;

const int FRONT_LEFT_REVERSE_PIN = 32;
const int FRONT_RIGHT_REVERSE_PIN = 25;

// REAR (GREY): A IS RIGHT B IS LEFT
const int REAR_LEFT_FORWARD_PIN = 4;
const int REAR_RIGHT_FORWARD_PIN = 13;

const int REAR_LEFT_REVERSE_PIN = 27;
const int REAR_RIGHT_REVERSE_PIN = 12;

// Master ESP Troubleshooting LED
int LED_PIN = 2;



// ==============================
// Convinience Stuff
// ==============================


void STARTUP() {
  for(int count=0; count<15; count++) {
    pinMode(LED_PIN, HIGH);
    delay(100);
    pinMode(LED_PIN, LOW);
    delay(100);
  }
  Serial.println("READY");
}


// ==============================
// ESP NOW COMMUNICATION
// ==============================

void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
    Serial.println(status == ESP_NOW_SEND_SUCCESS ? "MASTER> SENT SLAVE: " + PREVIOUS_COMMAND: "MASTER> FAILED TO SEND");
}

void OnDataRecv(const esp_now_recv_info_t *recvInfo, const uint8_t *incomingData, int len) {
  COMMAND = String((char*)incomingData);
  if(STARTUP_CHECK_COMPLETE) {
    if(MOVING) {
      MOVEMENT_COMMAND = COMMAND;
      Serial.print("SLAVE> MOVING> "); Serial.println(COMMAND);
    }
    else if (RPSING) {
      RPS_COMMAND = COMMAND;
      Serial.print("SLAVE> RPSING> "); Serial.println(COMMAND);
    }
    else if (LISTENING) {
      LISTEN_COMMAND = COMMAND;
      Serial.print("SLAVE> LISTENING> "); Serial.println(COMMAND);
    }
    else {
      Serial.println ("ERROR: NOT MOVEMENT, RPSING OR LISTENING");
    }
  }
  else {
    if (COMMAND == "LIVE") {
      Serial.print("SLAVE> "); Serial.println(COMMAND);
      STARTUP_CHECK_COMPLETE = true;
      Serial.println("MASTER> SLAVE READY");
    }
    else {
      Serial.println("MASTER> I Don't think I'm supposed to get here?");
    }
  }
}


void sendMessage(String msg) {
    PREVIOUS_COMMAND = msg;  // Store the message before sending
    esp_now_send(peerMac, (uint8_t *)msg.c_str(), msg.length() + 1);
}


// ==============================
// TELL SHOUTS
// ==============================

void Tell_Shout(String COMMAND) {
  if (COMMAND.equals("STARTUP")) {
    sendMessage("STARTUP");
  }
  else {
    if(COMMAND.equals("LISTEN")) {
    sendMessage("LISTEN");
    }
    else {
      if (COMMAND.equals("RPS")) {
        sendMessage("RPS");
      }
      else {
        if (COMMAND.equals("MOVEMENT")) {
          sendMessage("MOVEMENT");
        }
        else {
          Serial.println("MASTER> TELL SHOUT ERROR UNRECOGNISED COMMAND: "+COMMAND);
        }
      }
    }
  }
}

// ==============================
// Movement Functions 
// ==============================

void go_forward(double value) {
  double duration = value*1000.0; // Value multiplier here needs to be calibrated when prototype is made
  double start = 0.0;
  bool moving = false;

  if (!moving) {
    start = millis(); 
    moving = true;
  } 
  
  while(moving) {
    if (millis() - start < duration) {
    digitalWrite(FRONT_RIGHT_FORWARD_PIN, HIGH);
    digitalWrite(REAR_LEFT_FORWARD_PIN, HIGH);
    digitalWrite(FRONT_LEFT_FORWARD_PIN, HIGH);
    digitalWrite(REAR_RIGHT_FORWARD_PIN, HIGH);
  } else {
    digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
    digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
    digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
    digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
    moving = false;
    } 
  }
}

void go_back(double value) {
  double duration = value*1000.0; // Value multiplier here needs to be calibrated when prototype is made
  double start = 0.0;
  bool moving = false;

  if (!moving) {
    start = millis(); 
    moving = true;
  } 
  
  while(moving) {
    if (millis() - start < duration) {
    digitalWrite(FRONT_RIGHT_REVERSE_PIN, HIGH);
    digitalWrite(REAR_LEFT_REVERSE_PIN, HIGH);
    digitalWrite(FRONT_LEFT_REVERSE_PIN, HIGH);
    digitalWrite(REAR_RIGHT_REVERSE_PIN, HIGH);
  } else {
    digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
    digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
    digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
    digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
    moving = false;
    } 
  }
}

void rotate_left (double value) { // Scuffed Method Since we're not using a gyro - in degrees
  double duration = value*10.0; // Value multiplier here needs to be calibrated when prototype is made
  double start = 0.0;
  bool rotating = false;

  if (!rotating) {
    start = millis(); 
    rotating = true;
  } 

  while(rotating) {
    if (millis() - start < duration) {
    digitalWrite(FRONT_RIGHT_FORWARD_PIN, HIGH);
    digitalWrite(REAR_LEFT_FORWARD_PIN, HIGH);
    digitalWrite(FRONT_LEFT_REVERSE_PIN, HIGH);
    digitalWrite(REAR_RIGHT_REVERSE_PIN, HIGH);
  } else {
    digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
    digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
    digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
    digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
    rotating = false;
    } 
  }
}

void rotate_right (double value) { // Scuffed Method Since we're not using a gyro - in degrees
  double duration = value*10.0; // Value multiplier here needs to be calibrated when prototype is made
  double start = 0.0;
  bool rotating = false;

  if (!rotating) {
    start = millis(); 
    rotating = true;
  } 
  
  while(rotating) {
    if (millis() - start < duration) {
    digitalWrite(FRONT_LEFT_FORWARD_PIN, HIGH);
    digitalWrite(REAR_RIGHT_FORWARD_PIN, HIGH);
    digitalWrite(FRONT_RIGHT_REVERSE_PIN, HIGH);
    digitalWrite(REAR_LEFT_REVERSE_PIN, HIGH);
  } else {
    digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
    digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
    digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
    digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
    rotating = false;
    } 
  }
  
}

void shake(int intensity, int number_of_times) {
  for(int count=0;count<number_of_times;count++) {
    rotate_left(intensity);
    rotate_right(intensity);
  }
}

void arms(int degrees) {
  ARM1.write(degrees);
}

void arms_reset() {
  ARM1.write(0);
}

void arms_shake(int degrees, int number_of_times) {
  for(int count=0;count<number_of_times;count++) {
    arms_reset();
    delay(1000);
    ARM1.write(degrees);
  }
}

// ==============================
// Faces
// ==============================

void DEFAULT_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
}
void Blink_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(29, 28, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 28, 34, 15, 45, WHITE);
  oled.display();
  delay(100);
}
void Neutral_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(2500);
  Blink_FACE();
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(2500);
  Blink_FACE();
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
}

void Happy_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(29, 21, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 21, 34, 15, 45, WHITE);
  oled.fillRoundRect(32, 24, 29, 15, 45, BLACK);
  oled.fillRoundRect(68, 24, 29, 15, 45, BLACK);
  oled.display();
  delay(350);
  oled.clearDisplay();
  oled.fillRoundRect(29, 23, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 23, 34, 15, 45, WHITE);
  oled.fillRoundRect(31, 26, 29, 15, 45, BLACK);
  oled.fillRoundRect(67, 26, 29, 15, 45, BLACK);
  oled.display();
  delay(350);
}

void Idle_FACE() {
  oled.clearDisplay();
  oled.drawRect(43, 18, 18, 32, WHITE);
  oled.drawRect(78, 18, 18, 32, WHITE);
  oled.display();
}

void Angry_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(29, 18, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 18, 34, 15, 45, WHITE);
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1000);
}

void Look_Around_FACE() {
  //Left
  oled.clearDisplay();
  oled.fillRoundRect(28, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(64, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1500);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  //Blink
  oled.clearDisplay();
  oled.fillRoundRect(29, 28, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 28, 34, 15, 45, WHITE);
  oled.display();
  delay(100);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1750);
  //Blink
  oled.clearDisplay();
  oled.fillRoundRect(29, 28, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 28, 34, 15, 45, WHITE);
  oled.display();
  delay(100);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  //Right
  oled.clearDisplay();
  oled.fillRoundRect(48, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(84, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1500);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
}

void RPS_FACE() {
  oled.clearDisplay();
  ROCK_FACE();
  delay(500);
  PAPER_FACE();
  delay(500);
  SCISSORS_FACE();
  delay(500);
  ROCK_FACE();
  delay(500);
  PAPER_FACE();
  delay(500);
  SCISSORS_FACE();
  delay(500);
  DEFAULT_FACE();
}

void ROCK_FACE() {
  oled.clearDisplay();
  oled.drawCircle();
}

void PAPER_FACE() {
  oled.clearDisplay();
  oled.drawRect();
}

void SCISSORS_FACE() {
  oled.clearDisplay();
  oled.drawLine();
  oled.drawLine();
}

void BOOTING() {
  oled.clearDisplay();
  oled.drawRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.drawRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
}

// ==============================
// Behaviours
// ==============================



void Be_Self() {
  Happy_FACE();
  Idle_FACE();
  rock_paper_scissors();
  Idle_FACE();
}

void Movement_Listen() {

  MOVING = true;
  Serial.println("MASTER> Entered Manual Mode");
  while(MOVING) {
    delay(100);
    Tell_Shout("MOVEMENT");
    
    if(MOVEMENT_COMMAND == "Manual_OFF") {
      MOVING = false;
    }
    else {
      if (MOVEMENT_COMMAND == "FORWARD") {
        Serial.println("MASTER> Motion: Going Forward");
        go_forward(0.25);
        MOVEMENT_COMMAND = "VOID";
      }
      else {
        if (MOVEMENT_COMMAND == "REVERSE") {
          Serial.println("MASTER> Motion: Going Back");
          go_back(0.25);
          MOVEMENT_COMMAND = "VOID";
        }
        else {
          if (MOVEMENT_COMMAND == "LEFT") {
            Serial.println("MASTER> Motion: Turning Left");
            rotate_left(45);
            MOVEMENT_COMMAND = "VOID";
          }
          else {
            if (MOVEMENT_COMMAND == "RIGHT") {
              Serial.println("MASTER> Motion: Turning Right");
              rotate_right(45);
              MOVEMENT_COMMAND = "VOID";
            }
            else {
              if(MOVEMENT_COMMAND == "VOID" || MOVEMENT_COMMAND == "") {
                  Serial.println("MASTER> MOVEMENT_LISTEN> NO COMMAND");
              }
              else {
                Serial.println("MASTER> Movement_Listen: UNRECOGNIZED COMMAND: " + MOVEMENT_COMMAND);
                Error();
              }
            }
          } 
        }
      }
    }
  }
  digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
  digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
  digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
  digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
  digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
  digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
  digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
  digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
  Serial.println("MASTER> Exitted Manual Mode");
}

int RPS_Listen() {
  Serial.println("MASTER> RPS LISTENING");
  while(RPSING) {
    delay(100);
    Tell_Shout("RPS");
    if (RPS_COMMAND == "ROCK") {
      RPS_COMMAND = "VOID";
      RPSING = false;
      return 1;
    }
    else {
      if (RPS_COMMAND == "PAPER") {
        RPS_COMMAND = "VOID";
        RPSING = false;
        return 2;
      }
      else {
        if (RPS_COMMAND == "SCISSORS") {
          RPS_COMMAND = "VOID";
          RPSING = false;
          return 3;
        }
        else {
          if (RPS_COMMAND == "VOID") {
            Serial.println("MASTER> RPS_LISTEN> NO COMMAND");
          }
          else {
            Serial.println("RPS_Listen: Unrecognised Entry" + RPS_COMMAND);
          }
        }
      }
    }
  }
}


void playful() {
  Happy_FACE();
  Listen();
}


void alone() {
  Idle_FACE();
  arms(15);
  delay(300);
  arms(0);
  delay(300);
  arms(25);
  delay(300);
  arms(0);
  delay(300);
  arms(15);
  delay(300);
  arms(0);
  delay(300);
  arms(25);
  delay(300);
  arms(0);
  delay(300);
  arms(15);
  delay(300);
  arms(0);
  delay(300);
  arms(25);
  delay(300);
  arms(0);
}

void Win() {
  Happy_FACE();
  arms(90);
  delay(300);
  arms(0);
  delay(300);
  arms(90);
  delay(300);
  arms(0);
  delay(300);
  arms(90);
  delay(300);
  arms(0);
}

void Lose() {
  Angry_FACE();
  arms(45);
  delay(300);
  arms(0);
  delay(300);
  arms(45);
  delay(300);
  arms(0);
  delay(300);
  arms(45);
  delay(300);
  arms(0);

}


// ==============================
// Play Functions
// ==============================

void rock_paper_scissors() {
  int BOT_PICK = random(1, 4);
  int PLAYER_PICK;
  RPSING = true;

  while(RPSING) {
    RPS_FACE();
    arms(90);
    delay(350);
    arms(45);
    delay(350);
    arms(90);
    delay(350);
    arms(45);
    delay(350);
    arms(90);
    delay(350);
    arms(0);
    PLAYER_PICK = RPS_Listen();

    if(BOT_PICK == PLAYER_PICK) {
      Angry_FACE();
      delay(2000);
    }
    else {
      if(BOT_PICK == 1 && PLAYER_PICK == 3) { // BOT ROCK, PLAYER SCISSORS
        ROCK_FACE();
        delay(1000);
        Win();
      }
      else {
        if(BOT_PICK == 2 && PLAYER_PICK == 1) { // BOT PAPER, PLAYER ROCK
          PAPER_FACE();
          delay(1000);
          Win();
        }
        else {
          if(BOT_PICK == 3 && PLAYER_PICK == 2) { // BOT SCISSORS, PLAYER PAPER
            SCISSORS_FACE();
            delay(1000);
            Win();
          }
          else {
            if(BOT_PICK == 1) {
              ROCK_FACE();
              delay(1000);
              Lose();
            }
            else {
              if(BOT_PICK == 2) {
                PAPER_FACE();
                delay(1000);
                Lose();
              }
              else {
                if(BOT_PICK == 3) {
                  SCISSORS_FACE();
                  delay(1000);
                  Lose();
                }
              }
            }
          }
        }
      }
    }
  }
}

// ==============================
// Other
// ==============================

void Error() {
  digitalWrite(LED_PIN, HIGH);
  delay(1000);
  digitalWrite(LED_PIN, LOW);
}

// ==============================
// LISTEN
// ==============================

void Listen() {
  LISTENING = true;
  Tell_Shout("LISTEN");
  for(int count=0; count<4; count++) {
    rotate_right(90);
    Look_Around_FACE();
  }
  delay(1500);

  if (LISTEN_COMMAND == "Be_Self_alone") {
    LISTEN_COMMAND = "VOID";
    alone();
  }
  else {
    if (LISTEN_COMMAND == "Be_Self") {
      LISTEN_COMMAND = "VOID";
      Be_Self();
    }
    else {
      if (LISTEN_COMMAND == "Manual_ON") {
        LISTEN_COMMAND = "VOID";
        Movement_Listen();
      }
      else {
        if (LISTEN_COMMAND == "RPS") {
          LISTEN_COMMAND = "VOID";
          rock_paper_scissors();
        }
        else {
          if(LISTEN_COMMAND != "VOID") {
            Serial.println("MASTER> LISTEN> NO COMMAND");
          }
          Serial.println("MASTER> LISTEN: UNRECOGNISED COMMAND: " + LISTEN_COMMAND);
          Error();
        }
      }
    }
  }
}







// ==============================
// Setup & Loop
// ==============================

void setup() {
  // Serial
  Serial.begin(115200);

  // ESP NOW
  WiFi.mode(WIFI_STA);
    
  if (esp_now_init() != ESP_OK) {
      Serial.println("ESP-NOW Init Failed!");
      return;
  }
    
  esp_now_register_send_cb(OnDataSent);
  esp_now_peer_info_t peerInfo = {};
  memcpy(peerInfo.peer_addr, peerMac, 6);
  peerInfo.channel = 0;  
  peerInfo.encrypt = false;
    
  if (esp_now_add_peer(&peerInfo) != ESP_OK) {
      Serial.println("Failed to add peer");
      return;
  }
    
  esp_now_register_recv_cb(OnDataRecv);
  
  
  // Servo
  ARM1.attach(ARM1_PIN);
  // Motor Outputs
  pinMode(FRONT_LEFT_FORWARD_PIN, OUTPUT);
  pinMode(FRONT_RIGHT_FORWARD_PIN, OUTPUT);
  pinMode(FRONT_LEFT_REVERSE_PIN, OUTPUT);
  pinMode(FRONT_RIGHT_REVERSE_PIN, OUTPUT);
  pinMode(REAR_LEFT_FORWARD_PIN, OUTPUT);
  pinMode(REAR_RIGHT_FORWARD_PIN, OUTPUT);
  pinMode(REAR_LEFT_REVERSE_PIN, OUTPUT);
  pinMode(REAR_RIGHT_REVERSE_PIN, OUTPUT);
  pinMode(LED_PIN, OUTPUT);

  digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
  digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
  digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
  digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
  digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
  digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
  digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
  digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
  digitalWrite(LED_PIN, LOW);

  // OLED 
  if (!oled.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("failed to start SSD1306 OLED"));
    Error();
    while (1);
  }
  delay(2000);
  oled.setCursor(0, 0);
  oled.clearDisplay();


  BOOTING();
}

void loop() {
  static unsigned long lastSendTime = 0;

  if (!STARTUP_CHECK_COMPLETE) {
    if (millis() - lastSendTime > 1000) {  
      Tell_Shout("STARTUP");
      lastSendTime = millis(); 
    }
    STARTUP();
  } 
  else {
    Listen();
  }
}
