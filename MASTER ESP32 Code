// To do:

/* 
1: Fix Motor Pins When Installed Into Body
2: Write Be_Self();
3: Write Tell_Shout(); Communication System to Slave ESP32
4: Write alone();
5: Finish rock paper scissors + faces
6. Finish Remaining Behaviours (+ Win and Lose)

*/


// ==============================
// Global Variables
// ==============================



// ==============================
// Pre Setup
// ==============================
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <ESP32Servo.h>


//Servo
Servo ARM1;

//OLED
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET     -1
#define SCREEN_ADDRESS 0x3C
Adafruit_SSD1306 oled(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);



// ==============================
// Pins
// ==============================

//Servo
const int ARM1_PIN = 15;

//Wheels
//FRONT (WHITE): A IS RIGHT B IS LEFT

const int FRONT_LEFT_FORWARD_PIN = 33;
const int FRONT_RIGHT_FORWARD_PIN = 26;

const int FRONT_LEFT_REVERSE_PIN = 32;
const int FRONT_RIGHT_REVERSE_PIN = 25;

//REAR (GREY): A IS RIGHT B IS LEFT
const int REAR_LEFT_FORWARD_PIN = 4;
const int REAR_RIGHT_FORWARD_PIN = 13;

const int REAR_LEFT_REVERSE_PIN = 27;
const int REAR_RIGHT_REVERSE_PIN = 12;

//Master ESP Troubleshooting LED
const int LED_PIN = 2;



// ==============================
// Convinience Functions
// ==============================

// ==============================
// TELL SHOUT
// ==============================

void Tell_Shout(String Shout) {
  if(Shout == "LISTEN") {
    Serial.println("TELL SHOUT: LISTEN");
  }
  else {
    if(Shout == "STARTUP") {
      Serial.println("TELL SHOUT: STARTUP");
    }
    else {
      pinMode(LED_PIN, HIGH);
      while(true) {
        Serial.println("TELL SHOUT ERROR LOCK. RECIEVED COMMAND: " + Shout);
      }
    }
  }
}

// ==============================
// Movement Functions 
// ==============================

void go_forward(double value) {
  const double duration = value*1000.0; // Value multiplier here needs to be calibrated when prototype is made
  static  double start = 0.0;
  static bool moving = false;

  if (!moving) {
    start = millis(); 
    moving = true;
  } 
  
  while(moving) {
    if (millis() - start < duration) {
    digitalWrite(FRONT_RIGHT_FORWARD_PIN, HIGH);
    digitalWrite(REAR_LEFT_FORWARD_PIN, HIGH);
    digitalWrite(FRONT_LEFT_FORWARD_PIN, HIGH);
    digitalWrite(REAR_RIGHT_FORWARD_PIN, HIGH);
  } else {
    digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
    digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
    digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
    digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
    moving = false;
    } 
  }
}

void go_back(double value) {
  const double duration = value*1000.0; // Value multiplier here needs to be calibrated when prototype is made
  static double start = 0.0;
  static bool moving = false;

  if (!moving) {
    start = millis(); 
    moving = true;
  } 
  
  while(moving) {
    if (millis() - start < duration) {
    digitalWrite(FRONT_RIGHT_REVERSE_PIN, HIGH);
    digitalWrite(REAR_LEFT_REVERSE_PIN, HIGH);
    digitalWrite(FRONT_LEFT_REVERSE_PIN, HIGH);
    digitalWrite(REAR_RIGHT_REVERSE_PIN, HIGH);
  } else {
    digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
    digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
    digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
    digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
    moving = false;
    } 
  }
}

void rotate_left (double value) { // Scuffed Method Since we're not using a gyro - in degrees
  const double duration = value*10.0; // Value multiplier here needs to be calibrated when prototype is made
  static double start = 0.0;
  static bool rotating = false;

  if (!rotating) {
    start = millis(); 
    rotating = true;
  } 

  while(rotating) {
    if (millis() - start < duration) {
    digitalWrite(FRONT_RIGHT_FORWARD_PIN, HIGH);
    digitalWrite(REAR_LEFT_FORWARD_PIN, HIGH);
    digitalWrite(FRONT_LEFT_REVERSE_PIN, HIGH);
    digitalWrite(REAR_RIGHT_REVERSE_PIN, HIGH);
  } else {
    digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
    digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
    digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
    digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
    rotating = false;
    } 
  }
}

void rotate_right (double value) { // Scuffed Method Since we're not using a gyro - in degrees
  const double duration = value*10.0; // Value multiplier here needs to be calibrated when prototype is made
  static double start = 0.0;
  static bool rotating = false;

  if (!rotating) {
    start = millis(); 
    rotating = true;
  } 
  
  while(rotating) {
    if (millis() - start < duration) {
    digitalWrite(FRONT_LEFT_FORWARD_PIN, HIGH);
    digitalWrite(REAR_RIGHT_FORWARD_PIN, HIGH);
    digitalWrite(FRONT_RIGHT_REVERSE_PIN, HIGH);
    digitalWrite(REAR_LEFT_REVERSE_PIN, HIGH);
  } else {
    digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
    digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
    digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
    digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
    rotating = false;
    } 
  }
  
}

void shake(int intensity, int number_of_times) {
  for(int count=0;count<number_of_times;count++) {
    rotate_left(intensity);
    rotate_right(intensity);
  }
}

void arms(int degrees) {
  ARM1.write(degrees);
}

void arms_reset() {
  ARM1.write(0);
}

void arms_shake(int degrees, int number_of_times) {
  for(int count=0;count<number_of_times;count++) {
    arms_reset();
    delay(1000);
    ARM1.write(degrees);
  }
}

// ==============================
// Faces
// ==============================

void Blink_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(29, 28, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 28, 34, 15, 45, WHITE);
  oled.display();
  delay(100);
}
void Neutral_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(2500);
  Blink_FACE();
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(2500);
  Blink_FACE();
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
}

void Happy_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(29, 21, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 21, 34, 15, 45, WHITE);
  oled.fillRoundRect(32, 24, 29, 15, 45, BLACK);
  oled.fillRoundRect(68, 24, 29, 15, 45, BLACK);
  oled.display();
  delay(350);
  oled.clearDisplay();
  oled.fillRoundRect(29, 23, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 23, 34, 15, 45, WHITE);
  oled.fillRoundRect(31, 26, 29, 15, 45, BLACK);
  oled.fillRoundRect(67, 26, 29, 15, 45, BLACK);
  oled.display();
  delay(350);
}

void Idle_FACE() {
  oled.clearDisplay();
  oled.drawRect(43, 18, 18, 32, WHITE);
  oled.drawRect(78, 18, 18, 32, WHITE);
  oled.display();
}

void Angry_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(29, 18, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 18, 34, 15, 45, WHITE);
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1000);
}

void Look_Around_FACE() {
  //Left
  oled.clearDisplay();
  oled.fillRoundRect(28, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(64, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1500);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  //Blink
  oled.clearDisplay();
  oled.fillRoundRect(29, 28, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 28, 34, 15, 45, WHITE);
  oled.display();
  delay(100);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1750);
  //Blink
  oled.clearDisplay();
  oled.fillRoundRect(29, 28, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 28, 34, 15, 45, WHITE);
  oled.display();
  delay(100);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  //Right
  oled.clearDisplay();
  oled.fillRoundRect(48, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(84, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1500);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
}

void BOOTING() {
  oled.clearDisplay();
  oled.drawRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.drawRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
}

// ==============================
// Behaviours
// ==============================

void Be_Self() {
  Happy_FACE();
  Idle_FACE();
  rock_paper_scissors();
  Idle_FACE();
}

void Listen() {
  Tell_Shout("LISTEN");
  if (Serial.available() > 0) {  // Check if data is available from the slave
    String command = Serial.readString();  // Read the incoming command from the slave
    Serial.println("Received Command: " + command);  // Print the command


    if (command == "Be_Self_alone") {
      alone();
    }
    else {
      if (command == "Be_Self") {
        Be_Self();
      }
      else {
        if (command == "Manual_ON") {
          Movement_Listen();
        }
        else {
          if (command == "RPS") {
            rock_paper_scissors();
          }
          else {
            Serial.println("Listen: Unrecognised Command: " + command);
          }
        }
      }
    }
  }
}

void Movement_Listen() {

  bool Manual_MODE = true;
  
  while(Manual_MODE==true) {
    String command = Serial.readString();

    if(command == "Manual_OFF") {
      Manual_MODE = false;
    }
    else {
      if (command == "FORWARD") {
      Serial.println("Motion: Going Forward");
      go_forward(0.25);
      }
      else {
        if (command == "REVERSE") {
          Serial.println("Motion: Going Back");
          go_back(0.25);
        }
        else {
          if (command == "LEFT") {
            Serial.println("Motion: Turning Left");
            rotate_left(0.25);
          }
          else {
            if (command == "RIGHT") {
              Serial.println("Motion: Turning Right");
              rotate_right(0.25);
            }
            else {
                Serial.println("Movement_Listen: Unrecognised command: " + command);
                Error();
            }
          }
        }
      }
    }
  }
  digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
  digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
  digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
  digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
  digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
  digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
  digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
  digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW)
}

int RPS_Listen() {
  String command = Serial.readString();

  if (command == "ROCK") {
    return 1;
  }
  else {
    if (command == "PAPER") {
      return 2;
    }
    else {
      if (command == "SCISSORS") {
        return 3;
      }
      else {
        Serial.println("RPS_Listen: Unrecognised Command" + command);
      }
    }
  }
}


void playful() {
  Happy_FACE();
  Listen();
}


void alone() {
  Idle_FACE();
}

void Win() {
 Happy_FACE();


}

void Lose() {
  Angry_FACE();


}


// ==============================
// Play Functions
// ==============================

void rock_paper_scissors() {
  int BOT_PICK = random(1, 4);
  int PLAYER_PICK = RPS_Listen();

  if(BOT_PICK==PLAYER_PICK) {
    rock_paper_scissors();
  }
  else {
    if(BOT_PICK == 1 && PLAYER_PICK == 3) {
      Win();
    }
    else {
      if(BOT_PICK == 2 && PLAYER_PICK == 1) {
        Win();
      }
      else {
        if(BOT_PICK == 3 && PLAYER_PICK == 2) {
          Win();
        }
        else {
          Lose();
        }
      }
    }
  }
}





// ==============================
// Other
// ==============================

void Error() {
  digitalWrite(LED_PIN, HIGH);
  delay(1000);
  digitalWrite(LED_PIN, LOW);
}

// ==============================
// Setup & Loop
// ==============================

void setup() {
  // Serial
  Serial.begin(115200);
  // Servo
  ARM1.attach(ARM1_PIN);
  // Motor Outputs
  pinMode(FRONT_LEFT_FORWARD_PIN, OUTPUT);
  pinMode(FRONT_RIGHT_FORWARD_PIN, OUTPUT);
  pinMode(FRONT_LEFT_REVERSE_PIN, OUTPUT);
  pinMode(FRONT_RIGHT_REVERSE_PIN, OUTPUT);
  pinMode(REAR_LEFT_FORWARD_PIN, OUTPUT);
  pinMode(REAR_RIGHT_FORWARD_PIN, OUTPUT);
  pinMode(REAR_LEFT_REVERSE_PIN, OUTPUT);
  pinMode(REAR_RIGHT_REVERSE_PIN, OUTPUT);
  pinMode(LED_PIN, OUTPUT);

  digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
  digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
  digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
  digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
  digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
  digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
  digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
  digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
  digitalWrite(LED_PIN, LOW);

  // OLED 
  if (!oled.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("failed to start SSD1306 OLED"));
    Error();
    while (1);
  }

  delay(2000);
  oled.setCursor(0, 0);
  oled.clearDisplay();
  BOOTING();
  Tell_Shout("STARTUP");
}

void loop() {
  Listen();
}
