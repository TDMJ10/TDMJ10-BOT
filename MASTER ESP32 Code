/*
  Written by Naim Iftekhar Rahman (TDMJ10)
  tdmj10@gmail.com
  naimiftekharrahman@gmail.com
  naim.iftekhar.rahman@g.bracu.ac.bd
  +8801993537189
  Student of Bangldesh BRAC University (24201190)
  ROBU FALL 2024 BOR PROJECT
  TEAM I-NPC




        CAUTION:
       ---------
        THIS CODE CAN CAUSE BLUE SCREENS OF DEATH (IQRL_NOT_LESS_OR_EQUAL) ON WINDOWS
        DUE TO EXCESSIVE SERIAL PRINTS ON ARDUINO IDE DUE TO A BUG. (As of 3/6/25
        CLEAR YOUR SERIAL MONITOR REGULARLY.

        THIS CODE IS UNTESTED ON MAC OS. IT MAY CAUSE KERNEL PANICS OR CRASHES TOO.

 To do:
==========
1: Fix Motor Pins When Installed Into Body
2: Write Be_Self();
3: Write Tell_Shout(); Communication System to Slave ESP32
4: Write alone();
5: Finish rock paper scissors + faces
6. Finish Remaining Behaviours (+ Win and Lose)
7. Add servo movement to most actions
*/


// CHANGE THE MAC ADDRESSES TO YOUR ESP's MAC ADDRESS

// ==============================
// Global Variables
// ==============================

// ESP NOW + TELL SHOUT
String PREVIOUS_COMMAND = "ERROR";
String COMMAND = "ERROR";

// MOVEMENT
bool MOVING = false;
  // MOVEMENT TELLSHOUT
  String MOVEMENT_COMMAND = "ERROR";

// RPS
bool RPSING = false;
  // RPS TELLSHOUT
  String RPS_COMMAND = "ERROR";

// LISTEN
bool LISTENING = false;
  // LISTEN TELLSHOUT
  String LISTEN_COMMAND = "ERROR";

// SEARCHING
bool TURNING_AROUND = false;

// STARTUP TROUBLESHOOTING
bool STARTUP_CHECK_COMPLETE = false;


// ==============================
// Pre Setup
// ==============================
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <ESP32Servo.h>
#include <esp_now.h>
#include <WiFi.h>


//Servo
Servo ARM1;

//OLED
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
#define SCREEN_ADDRESS 0x3C
Adafruit_SSD1306 oled(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// ESP NOW COMMUNICATION
//uint8_t peerMac[] = { 0x94, 0x54, 0xC5, 0xB5, 0xC6, 0x8C };  // Placeholder for Naim's Main ESP32 CAM
uint8_t peerMac[] = { 0x94, 0x54, 0xC5, 0xB5, 0xC6, 0x8C };  // Naim's Testing ESP32 CAM


// ==============================
// Pins
// ==============================

// Servo
const int ARM1_PIN = 15;

// Wheels
// FRONT (WHITE): A IS RIGHT B IS LEFT

const int FRONT_LEFT_FORWARD_PIN = 33;
const int FRONT_RIGHT_FORWARD_PIN = 26;

const int FRONT_LEFT_REVERSE_PIN = 32;
const int FRONT_RIGHT_REVERSE_PIN = 25;

// REAR (GREY): A IS RIGHT B IS LEFT
const int REAR_LEFT_FORWARD_PIN = 4;
const int REAR_RIGHT_FORWARD_PIN = 13;

const int REAR_LEFT_REVERSE_PIN = 27;
const int REAR_RIGHT_REVERSE_PIN = 12;

// Master ESP Troubleshooting LED
const int LED_PIN = 2;



// ==============================
// Convinience Stuff
// ==============================


void STARTUP() {
  digitalWrite(LED_PIN, HIGH);
  delay(250);
  digitalWrite(LED_PIN, LOW);
  delay(250);
  Serial.println("MASTER> READY TO COMMUNICATE");
  DEFAULT_FACE();
  delay(10);
}


// ==============================
// ESP NOW COMMUNICATION
// ==============================

void OnDataSent(const uint8_t *mac_addr, esp_now_send_status_t status) {
  Serial.println(status == ESP_NOW_SEND_SUCCESS ? "MASTER> SENT SLAVE: " + PREVIOUS_COMMAND : "MASTER> FAILED TO COMMUNICATE WITH SLAVE");
  delay(10);
}

void OnDataRecv(const esp_now_recv_info_t *recvInfo, const uint8_t *incomingData, int len) {
  COMMAND = String((char *)incomingData);
  if (STARTUP_CHECK_COMPLETE) {
    if(!TURNING_AROUND) {
      if (MOVING) {
        MOVEMENT_COMMAND = COMMAND;
        Serial.print("SLAVE> MOVING> ");
        Serial.println(COMMAND);
      }
      else {
        if (RPSING) {
          RPS_COMMAND = COMMAND;
          Serial.print("SLAVE> RPSING> ");
          Serial.println(COMMAND);
        }
        else {
          if (LISTENING) {
            LISTEN_COMMAND = COMMAND;
            Serial.print("SLAVE> LISTENING> ");
            Serial.println(COMMAND);
          }
          else {
            Serial.println("ERROR: NOT MOVEMENT, RPSING OR LISTENING");
          } 
        }
      }
    }
    else {
      ERROR_INVERSE();
      if (MOVING) {
        MOVEMENT_COMMAND = COMMAND;
        Serial.print("SLAVE> MOVING> ");
        Serial.println(COMMAND);
      }
      else {
        if (RPSING) {
          RPS_COMMAND = COMMAND;
          Serial.print("SLAVE> RPSING> ");
          Serial.println(COMMAND);
        }
        else {
          if (LISTENING) {
            LISTEN_COMMAND = COMMAND;
            Serial.print("SLAVE> LISTENING> ");
            Serial.println(COMMAND);
          }
          else {
            Serial.println("ERROR: NOT MOVEMENT, RPSING OR LISTENING");
          } 
        }
      }
    }
  } 
  else {
    if (COMMAND == "LIVE") {
      Serial.print("SLAVE> ");
      Serial.println(COMMAND);
      STARTUP_CHECK_COMPLETE = true;
      Serial.println("MASTER> SLAVE READY");
    } else {
      Serial.println("MASTER> I Don't think I'm supposed to get here?");
    }
  }
  delay(10);
}


void sendMessage(String msg) {
  PREVIOUS_COMMAND = msg;  // Store the message before sending
  esp_now_send(peerMac, (uint8_t *)msg.c_str(), msg.length() + 1);
  delay(10);
}


// ==============================
// TELL SHOUTS
// ==============================

void Tell_Shout(String COMMAND) {
  if (COMMAND.equals("STARTUP")) {
    sendMessage("STARTUP");
  } else {
    if (COMMAND.equals("LISTEN")) {
      sendMessage("LISTEN");
    } else {
      if (COMMAND.equals("RPS")) {
        sendMessage("RPS");
      } else {
        if (COMMAND.equals("MOVEMENT")) {
          sendMessage("MOVEMENT");
        } else {
          Serial.println("MASTER> TELL SHOUT ERROR UNRECOGNISED COMMAND: " + COMMAND);
        }
      }
    }
  }
  delay(10);
}

// ==============================
// Movement Functions
// ==============================

void go_forward(double value) {
  double duration = value * 1000.0;  // Value multiplier here needs to be calibrated when prototype is made
  double start = 0.0;
  bool moving = false;

  if (!moving) {
    start = millis();
    moving = true;
  }

  while (moving) {
    if (millis() - start < duration) {
      digitalWrite(FRONT_RIGHT_FORWARD_PIN, HIGH);
      digitalWrite(REAR_LEFT_FORWARD_PIN, HIGH);
      digitalWrite(FRONT_LEFT_FORWARD_PIN, HIGH);
      digitalWrite(REAR_RIGHT_FORWARD_PIN, HIGH);
    } else {
      digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
      digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
      digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
      digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
      moving = false;
    }
  }
  delay(10);
}

void go_back(double value) {
  double duration = value * 1000.0;  // Value multiplier here needs to be calibrated when prototype is made
  double start = 0.0;
  bool moving = false;

  if (!moving) {
    start = millis();
    moving = true;
  }

  while (moving) {
    if (millis() - start < duration) {
      digitalWrite(FRONT_RIGHT_REVERSE_PIN, HIGH);
      digitalWrite(REAR_LEFT_REVERSE_PIN, HIGH);
      digitalWrite(FRONT_LEFT_REVERSE_PIN, HIGH);
      digitalWrite(REAR_RIGHT_REVERSE_PIN, HIGH);
    } else {
      digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
      digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
      digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
      digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
      moving = false;
    }
  }
  delay(10);
}

void rotate_left(double value) {   // Scuffed Method Since we're not using a gyro - in degrees
  double duration = value * 10.0;  // Value multiplier here needs to be calibrated when prototype is made
  double start = 0.0;
  bool rotating = false;

  if (!rotating) {
    start = millis();
    rotating = true;
  }

  while (rotating) {
    if (millis() - start < duration) {
      digitalWrite(FRONT_RIGHT_FORWARD_PIN, HIGH);
      digitalWrite(REAR_LEFT_FORWARD_PIN, HIGH);
      digitalWrite(FRONT_LEFT_REVERSE_PIN, HIGH);
      digitalWrite(REAR_RIGHT_REVERSE_PIN, HIGH);
    } else {
      digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
      digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
      digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
      digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
      rotating = false;
    }
  }
  delay(10);
}

void rotate_right(double value) {  // Scuffed Method Since we're not using a gyro - in degrees
  double duration = value * 10.0;  // Value multiplier here needs to be calibrated when prototype is made
  double start = 0.0;
  bool rotating = false;

  if (!rotating) {
    start = millis();
    rotating = true;
  }

  while (rotating) {
    if (millis() - start < duration) {
      digitalWrite(FRONT_LEFT_FORWARD_PIN, HIGH);
      digitalWrite(REAR_RIGHT_FORWARD_PIN, HIGH);
      digitalWrite(FRONT_RIGHT_REVERSE_PIN, HIGH);
      digitalWrite(REAR_LEFT_REVERSE_PIN, HIGH);
    } else {
      digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
      digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
      digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
      digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
      rotating = false;
    }
  }
  delay(10);
}

void shake(int intensity, int number_of_times) {
  for (int count = 0; count < number_of_times; count++) {
    rotate_left(intensity);
    rotate_right(intensity);
  }
  delay(10);
}

void arms(int degrees) {
  ARM1.write(degrees);
  delay(10);
}

void arms_reset() {
  ARM1.write(0);
  delay(10);
}

void arms_shake(int degrees, int number_of_times) {
  for (int count = 0; count < number_of_times; count++) {
    arms_reset();
    delay(1000);
    ARM1.write(degrees);
  }
  delay(10);
}

// ==============================
// Faces
// ==============================

void DEFAULT_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(10);
}

void Blink_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(29, 28, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 28, 34, 15, 45, WHITE);
  oled.display();
  delay(100);
}
void Neutral_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(2500);
  Blink_FACE();
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(2500);
  Blink_FACE();
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(10);
}

void Happy_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(29, 21, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 21, 34, 15, 45, WHITE);
  oled.fillRoundRect(32, 24, 29, 15, 45, BLACK);
  oled.fillRoundRect(68, 24, 29, 15, 45, BLACK);
  oled.display();
  delay(350);
  oled.clearDisplay();
  oled.fillRoundRect(29, 23, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 23, 34, 15, 45, WHITE);
  oled.fillRoundRect(31, 26, 29, 15, 45, BLACK);
  oled.fillRoundRect(67, 26, 29, 15, 45, BLACK);
  oled.display();
  delay(350);
}

void Angry_FACE() {
  oled.clearDisplay();
  oled.fillRoundRect(29, 18, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 18, 34, 15, 45, WHITE);
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1000);
}

void Sad_FACE_1() {
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(10);
}

void Sad_FACE_2() {
  oled.clearDisplay();
  oled.fillRoundRect(35, 20, 18, 32, 45, WHITE);
  oled.fillRoundRect(71, 20, 18, 32, 45, WHITE);
  oled.display();
  delay(10);
}

void Sad_FACE_3() {
  oled.clearDisplay();
  oled.fillRoundRect(38, 22, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 22, 18, 32, 45, WHITE);
  oled.display();
  delay(10);
}

void Sad_FACE_4() {
  oled.clearDisplay();
  oled.fillRoundRect(41, 24, 18, 32, 45, WHITE);
  oled.fillRoundRect(77, 24, 18, 32, 45, WHITE);
  oled.display();
  delay(10);
}

void Sad_FACE_5() {
  oled.clearDisplay();
  oled.fillRoundRect(38, 25, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 25, 18, 32, 45, WHITE);
  oled.display();
  delay(10);
}

void Look_Around_FACE() {
  //Left
  oled.clearDisplay();
  oled.fillRoundRect(28, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(64, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1500);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  //Blink
  oled.clearDisplay();
  oled.fillRoundRect(29, 28, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 28, 34, 15, 45, WHITE);
  oled.display();
  delay(100);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1750);
  //Blink
  oled.clearDisplay();
  oled.fillRoundRect(29, 28, 34, 15, 45, WHITE);
  oled.fillRoundRect(65, 28, 34, 15, 45, WHITE);
  oled.display();
  delay(100);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  //Right
  oled.clearDisplay();
  oled.fillRoundRect(48, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(84, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(1500);
  //Center
  oled.clearDisplay();
  oled.fillRoundRect(38, 18, 18, 32, 45, WHITE);
  oled.fillRoundRect(74, 18, 18, 32, 45, WHITE);
  oled.display();
  delay(10);
}

void RPS_FACE() {
  oled.clearDisplay();
  ROCK_FACE();
  delay(500);
  PAPER_FACE();
  delay(500);
  SCISSORS_FACE();
  delay(500);
  ROCK_FACE();
  delay(500);
  PAPER_FACE();
  delay(500);
  SCISSORS_FACE();
  delay(500);
  DEFAULT_FACE();
  delay(10);
}

void ROCK_FACE() {
  oled.clearDisplay();
  //oled.drawCircle();
  oled.display();
  delay(10);
}

void PAPER_FACE() {
  oled.clearDisplay();
  //oled.drawRect();
  oled.display();
  delay(10);
}

void SCISSORS_FACE() {
  oled.clearDisplay();
  //oled.drawLine();
  //oled.drawLine();
  oled.display();
  delay(10);
}

void BOOTING() {
  oled.clearDisplay();
  oled.drawRect(43, 18, 18, 32, WHITE);
  oled.drawRect(78, 18, 18, 32, WHITE);
  oled.display();
  delay(10);
}

// ==============================
// Behaviours
// ==============================



void BE_SELF() {
  Playful();
  DEFAULT_FACE();
  delay(10);
}

void Movement_Listen() {

  MOVING = true;
  Serial.println("MASTER> MANUAL ACTIVE");
  while (MOVING) {
    Tell_Shout("REQUEST: MOVEMENT");

    if (MOVEMENT_COMMAND.equals("MANUAL_OFF")) {
      MOVING = false;
      MOVEMENT_COMMAND.equals("VOID");
      break;
    } else {
      if (MOVEMENT_COMMAND.equals("FORWARD")) {
        Serial.println("MASTER> MOVEMENT_LISTEN: Going Forward");
        go_forward(0.25);
        MOVEMENT_COMMAND = "VOID";
      } else {
        if (MOVEMENT_COMMAND.equals("REVERSE")) {
          Serial.println("MASTER> MOVEMENT_LISTEN: Going Back");
          go_back(0.25);
          MOVEMENT_COMMAND = "VOID";
        } else {
          if (MOVEMENT_COMMAND.equals("LEFT")) {
            Serial.println("MASTER> MOVEMENT_LISTEN: Turning Left");
            rotate_left(45);
            MOVEMENT_COMMAND = "VOID";
          } else {
            if (MOVEMENT_COMMAND.equals("RIGHT")) {
              Serial.println("MASTER> MOVEMENT_LISTEN: Turning Right");
              rotate_right(45);
              MOVEMENT_COMMAND = "VOID";
            } else {
              if (MOVEMENT_COMMAND.equals("VOID")) {
                Serial.println("MASTER> MOVEMENT_LISTEN: NO COMMAND");
              } else {
                Serial.println("MASTER> MOVEMENT_LISTEN> UNRECOGNIZED COMMAND: " + MOVEMENT_COMMAND);
                ERROR();
                MOVEMENT_COMMAND = "VOID";
              }
            }
          }
        }
      }
    }
    delay(1000);
  }
  digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
  delay(10);
  digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
  delay(10);
  digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
  delay(10);
  digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
  delay(10);
  digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
  delay(10);
  digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
  delay(10);
  digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
  delay(10);
  digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
  delay(10);
  Serial.println("MASTER> MANUAL DISENGAGED");
  MOVEMENT_COMMAND = "VOID";
  delay(10);
}

int RPS_Listen() {
  int RPS_LISTEN_ATTEMPTS = 0;
  Serial.println("MASTER> RPS LISTENING");
  while (RPSING && RPS_LISTEN_ATTEMPTS<3) {
    delay(1000);
    Tell_Shout("RPS");
    if (RPS_COMMAND.equals("ROCK")) {
      RPS_COMMAND = "VOID";
      return 1;
    } else {
      if (RPS_COMMAND.equals("PAPER")) {
        RPS_COMMAND = "VOID";
        return 2;
      } else {
        if (RPS_COMMAND.equals("SCISSORS")) {
          RPS_COMMAND = "VOID";
          return 3;
        } else {
          if (RPS_COMMAND.equals("VOID")) {
            Serial.println("MASTER> RPS_LISTEN> NO COMMAND");
          } else {
            Serial.println("MASTER> RPS_LISTEN> UNRECOGNIZED COMMAND: " + RPS_COMMAND);
            RPS_COMMAND = "VOID";
          }
        }
      }
    }
  }
  if(RPS_LISTEN_ATTEMPTS==3) {
    return 0;
  }
  RPS_COMMAND = "VOID";
  delay(10);
}


void Playful() {
  Happy_FACE();
  arms(45);
  delay(300);
  Happy_FACE();
  arms(0);
  delay(300);
  Happy_FACE();
  arms(45);
  delay(300);
  Happy_FACE();
  arms(0);
  delay(300);
  Happy_FACE();
  arms(45);
  delay(300);
  Happy_FACE();
  arms(0);
  delay(300);
  DEFAULT_FACE();
}


void Alone() {
  Sad_FACE_1();
  arms(15);
  delay(300);
  Sad_FACE_2();
  arms(0);
  delay(300);
  Sad_FACE_3();
  arms(25);
  delay(300);
  Sad_FACE_4();
  arms(0);
  delay(300);
  Sad_FACE_5();
  arms(15);
  delay(300);
  Sad_FACE_2();
  arms(0);
  delay(300);
  Sad_FACE_4();
  arms(25);
  delay(300);
  Sad_FACE_5();
  arms(0);
  delay(300);
  Sad_FACE_4();
  arms(15);
  delay(300);
  Sad_FACE_3();
  arms(0);
  delay(300);
  Sad_FACE_2();
  arms(25);
  delay(300);
  Sad_FACE_1();
  arms(0);
  delay(300);
  DEFAULT_FACE();
  delay(10);
}

void Win() {
  Serial.println("MASTER> RPS> BOT Won!");
  Happy_FACE();
  arms(90);
  delay(300);
  arms(0);
  delay(300);
  arms(90);
  delay(300);
  arms(0);
  delay(300);
  arms(90);
  delay(300);
  arms(0);
  delay(1000);
}

void Lose() {
  Serial.println("MASTER> RPS> BOT Lost...");
  Angry_FACE();
  arms(30);
  delay(500);
  arms(0);
  delay(500);
  arms(30);
  delay(500);
  arms(0);
  delay(500);
  arms(30);
  delay(500);
  arms(0);
  delay(1000);
}


// ==============================
// Play Functions
// ==============================

void RPS() {
  Serial.println("MASTER> Playing Rock Paper Scissors");
  int BOT_PICK;
  int PLAYER_PICK;
  RPSING = true;

  while (RPSING) {
    delay(3000);
    arms(90);
    delay(350);
    arms(45);
    delay(350);
    arms(90);
    delay(350);
    arms(45);
    delay(350);
    arms(90);
    delay(350);
    arms(0);
    PLAYER_PICK = RPS_Listen();
    BOT_PICK = random(1, 4);

    if (BOT_PICK == PLAYER_PICK || PLAYER_PICK == 0) {
      Angry_FACE();
      delay(3000);
      DEFAULT_FACE();
    } else {
      if (BOT_PICK == 1 && PLAYER_PICK == 3) {  // BOT ROCK, PLAYER SCISSORS
        ROCK_FACE();
        delay(1000);
        Win();
        RPSING = false;
      } else {
        if (BOT_PICK == 2 && PLAYER_PICK == 1) {  // BOT PAPER, PLAYER ROCK
          PAPER_FACE();
          delay(1000);
          Win();
          RPSING = false;
        } else {
          if (BOT_PICK == 3 && PLAYER_PICK == 2) {  // BOT SCISSORS, PLAYER PAPER
            SCISSORS_FACE();
            delay(1000);
            Win();
            RPSING = false;
          } else {
            if (BOT_PICK == 1) {
              ROCK_FACE();
              delay(1000);
              Lose();
              RPSING = false;
            } else {
              if (BOT_PICK == 2) {
                PAPER_FACE();
                delay(1000);
                Lose();
                RPSING = false;
              } else {
                if (BOT_PICK == 3) {
                  SCISSORS_FACE();
                  delay(1000);
                  Lose();
                  RPSING = false;
                }
              }
            }
          }
        }
      }
    }
  }
  delay(10);
}

// ==============================
// Other
// ==============================

void ERROR() {
  delay(10);
  digitalWrite(LED_PIN, HIGH);
  delay(1000);
  digitalWrite(LED_PIN, LOW);
  delay(10);
}

void ERROR_INVERSE() {
  delay(10);
  digitalWrite(LED_PIN, LOW);
  delay(1000);
  digitalWrite(LED_PIN, HIGH);
  delay(10);
}

// ==============================
// LISTEN
// ==============================

void Listen() {
  LISTENING = true;
  Tell_Shout("LISTEN");
  TURNING_AROUND = true;
  for (int count = 0; count < 4; count++) {
    if (LISTEN_COMMAND.equals("EXIT")){
      break;
    }
    rotate_right(90);
    Look_Around_FACE();
    digitalWrite(LED_PIN, HIGH);
    delay(10);
  }
  TURNING_AROUND = false;
  if (!LISTEN_COMMAND.equals("EXIT")) {
    Tell_Shout("LISTEN_TELL_ME");
  }
  digitalWrite(LED_PIN, LOW);
  delay(1500);

  if (LISTEN_COMMAND.equals("ALONE")) {
    LISTEN_COMMAND = "VOID";
    Alone();
  } else {
    if (LISTEN_COMMAND.equals("BE_SELF")) {
      LISTEN_COMMAND = "VOID";
      BE_SELF();
    } else {
      if (LISTEN_COMMAND.equals("MANUAL_ON")) {
        LISTEN_COMMAND = "VOID";
        Movement_Listen();
      } else {
        if (LISTEN_COMMAND.equals("RPS")) {
          LISTEN_COMMAND = "VOID";
          RPS();
        } else {
          if (LISTEN_COMMAND.equals("EXIT")) {
            Serial.println("MASTER> LISTEN> FORCE EXITTED");
            ERROR_INVERSE();
            ERROR();
          }
          else {
            if (LISTEN_COMMAND.equals("VOID")) {
              Serial.println("MASTER> LISTEN> NO COMMAND RECEIVED");
            } else {
              Serial.println("MASTER> LISTEN: UNRECOGNISED COMMAND: " + LISTEN_COMMAND);
              LISTEN_COMMAND = "VOID";
              ERROR();
            }
          }
        }
      }
    }
  }
  delay(10);
}







// ==============================
// Setup & Loop
// ==============================

void setup() {
  // Serial
  Serial.begin(115200);

  // ERROR LED
  pinMode(LED_PIN, OUTPUT);

  // ESP NOW
  WiFi.mode(WIFI_STA);

  if (esp_now_init() != ESP_OK) {
    Serial.println("ESP-NOW Init Failed!");
    return;
  }

  esp_now_register_send_cb(OnDataSent);
  esp_now_peer_info_t peerInfo = {};
  memcpy(peerInfo.peer_addr, peerMac, 6);
  peerInfo.channel = 0;
  peerInfo.encrypt = false;

  if (esp_now_add_peer(&peerInfo) != ESP_OK) {
    Serial.println("Failed to add peer");
    return;
  }

  esp_now_register_recv_cb(OnDataRecv);


  // Servo
  ARM1.attach(ARM1_PIN);
  // Motor Outputs
  pinMode(FRONT_LEFT_FORWARD_PIN, OUTPUT);
  delay(10);
  pinMode(FRONT_RIGHT_FORWARD_PIN, OUTPUT);
  delay(10);
  pinMode(FRONT_LEFT_REVERSE_PIN, OUTPUT);
  delay(10);
  pinMode(FRONT_RIGHT_REVERSE_PIN, OUTPUT);
  delay(10);
  pinMode(REAR_LEFT_FORWARD_PIN, OUTPUT);
  delay(10);
  pinMode(REAR_RIGHT_FORWARD_PIN, OUTPUT);
  delay(10);
  pinMode(REAR_LEFT_REVERSE_PIN, OUTPUT);
  delay(10);
  pinMode(REAR_RIGHT_REVERSE_PIN, OUTPUT);
  delay(10);

  digitalWrite(FRONT_LEFT_FORWARD_PIN, LOW);
  delay(10);
  digitalWrite(FRONT_RIGHT_FORWARD_PIN, LOW);
  delay(10);
  digitalWrite(FRONT_LEFT_REVERSE_PIN, LOW);
  delay(10);
  digitalWrite(FRONT_RIGHT_REVERSE_PIN, LOW);
  delay(10);
  digitalWrite(REAR_LEFT_FORWARD_PIN, LOW);
  delay(10);
  digitalWrite(REAR_RIGHT_FORWARD_PIN, LOW);
  delay(10);
  digitalWrite(REAR_LEFT_REVERSE_PIN, LOW);
  delay(10);
  digitalWrite(REAR_RIGHT_REVERSE_PIN, LOW);
  delay(10);
  digitalWrite(LED_PIN, LOW);
  delay(10);
  arms(0);

  // OLED
  if (!oled.begin(SSD1306_SWITCHCAPVCC, 0x3C)) {
    Serial.println(F("failed to start SSD1306 OLED"));
    ERROR();
    while (1)
      ;
  }
  delay(2000);
  oled.setCursor(0, 0);
  oled.clearDisplay();

  Serial.println("BOOTING");
  delay(1000);
  Serial.println("ACTIVE");
  BOOTING();
  delay(10);
}

void loop() {
  static unsigned long lastSendTime = 0;

  if (!STARTUP_CHECK_COMPLETE) {
    if (millis() - lastSendTime > 1000) {
      Tell_Shout("STARTUP");
      lastSendTime = millis();
    }
    STARTUP();
    delay(2500);
  } else {
    Listen();
  }
  delay(10);
}
